# Docker Compose Deployment Module
# Deploys HE-300 stack via Docker Compose to a target host

terraform {
  required_version = ">= 1.5.0"

  required_providers {
    null = {
      source  = "hashicorp/null"
      version = "~> 3.0"
    }
    local = {
      source  = "hashicorp/local"
      version = "~> 2.0"
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.0"
    }
  }
}

# Generate secrets if not provided
resource "random_password" "db_password" {
  length  = 24
  special = false
}

resource "random_password" "redis_password" {
  length  = 24
  special = false
}

resource "random_password" "jwt_secret" {
  length  = 32
  special = false
}

resource "random_password" "webhook_secret" {
  length  = 32
  special = false
}

# Generate .env file for Docker Compose
resource "local_file" "env_file" {
  filename = "${var.deploy_path}/.env"
  content  = <<-EOT
    # HE-300 Docker Compose Environment
    # Generated by Terraform - ${timestamp()}

    # Environment
    ENVIRONMENT=${var.environment}
    
    # Database
    POSTGRES_PASSWORD=${var.db_password != "" ? var.db_password : random_password.db_password.result}
    DB_PASSWORD=${var.db_password != "" ? var.db_password : random_password.db_password.result}
    
    # Redis
    REDIS_PASSWORD=${var.redis_password != "" ? var.redis_password : random_password.redis_password.result}
    
    # JWT
    JWT_SECRET=${var.jwt_secret != "" ? var.jwt_secret : random_password.jwt_secret.result}
    
    # Webhook
    WEBHOOK_SECRET=${var.webhook_secret != "" ? var.webhook_secret : random_password.webhook_secret.result}
    
    # Ports
    CIRISNODE_PORT=${var.cirisnode_port}
    EEE_PORT=${var.eee_port}
    DASHBOARD_PORT=${var.dashboard_port}
    
    # Model Configuration
    DEFAULT_MODEL=${var.default_model}
    MODEL_QUANTIZATION=${var.model_quantization}
    MODEL_CACHE_DIR=${var.model_cache_dir}
    
    # GPU Configuration
    CUDA_VISIBLE_DEVICES=${var.cuda_visible_devices}
    
    # Logging
    LOG_LEVEL=${var.log_level}
    
    # Data paths
    DATA_DIR=${var.data_dir}
    LOG_DIR=${var.log_dir}
  EOT

  file_permission = "0600"
}

# Generate Docker Compose override for environment-specific settings
resource "local_file" "compose_override" {
  filename = "${var.deploy_path}/docker-compose.override.yml"
  content  = <<-EOT
    version: '3.8'
    
    # Environment-specific overrides for ${var.environment}
    # Generated by Terraform
    
    services:
      cirisnode:
        environment:
          - ENVIRONMENT=${var.environment}
          - LOG_LEVEL=${var.log_level}
        %{if var.enable_gpu}
        deploy:
          resources:
            reservations:
              devices:
                - driver: nvidia
                  count: all
                  capabilities: [gpu]
        %{endif}
    
      ethicsengine:
        environment:
          - DEFAULT_MODEL=${var.default_model}
          - MODEL_QUANTIZATION=${var.model_quantization}
        %{if var.enable_gpu}
        deploy:
          resources:
            reservations:
              devices:
                - driver: nvidia
                  count: all
                  capabilities: [gpu]
        %{endif}
    
      %{if var.enable_dashboard}
      dashboard:
        ports:
          - "${var.dashboard_port}:3000"
      %{endif}
  EOT

  file_permission = "0644"
}

# Deploy to local or remote host
resource "null_resource" "deploy" {
  count = var.auto_deploy ? 1 : 0

  triggers = {
    env_file_hash    = local_file.env_file.content_md5
    compose_override = local_file.compose_override.content_md5
    deploy_path      = var.deploy_path
  }

  provisioner "local-exec" {
    command     = var.target_host == "localhost" ? local.local_deploy_cmd : local.remote_deploy_cmd
    working_dir = var.deploy_path
    environment = {
      DOCKER_HOST = var.docker_host
    }
  }

  depends_on = [local_file.env_file, local_file.compose_override]
}

locals {
  local_deploy_cmd = <<-EOT
    docker compose pull && \
    docker compose up -d
  EOT

  remote_deploy_cmd = <<-EOT
    ssh ${var.ssh_user}@${var.target_host} "cd ${var.deploy_path} && docker compose pull && docker compose up -d"
  EOT
}

# Health check after deployment
resource "null_resource" "health_check" {
  count = var.auto_deploy ? 1 : 0

  triggers = {
    deploy = null_resource.deploy[0].id
  }

  provisioner "local-exec" {
    command = <<-EOT
      echo "Waiting for services to start..."
      sleep 10
      
      # Check CIRISNode health
      for i in {1..30}; do
        if curl -sf http://${var.target_host}:${var.cirisnode_port}/health > /dev/null 2>&1; then
          echo "✅ CIRISNode is healthy"
          break
        fi
        echo "Waiting for CIRISNode... ($i/30)"
        sleep 2
      done
      
      # Check EthicsEngine health
      for i in {1..30}; do
        if curl -sf http://${var.target_host}:${var.eee_port}/health > /dev/null 2>&1; then
          echo "✅ EthicsEngine is healthy"
          break
        fi
        echo "Waiting for EthicsEngine... ($i/30)"
        sleep 2
      done
    EOT
  }

  depends_on = [null_resource.deploy]
}
